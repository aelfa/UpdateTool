/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package updatetool.gui;

import static updatetool.gui.Config.APPLICATION_CONFIG;
import static updatetool.gui.Config.INSTANCE;
import java.awt.Desktop;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import org.tinylog.Logger;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.Label;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.stage.Stage;

public class App extends Application {
    private static final String HEADER = readHeader();
    private static Parent parent;
    private static Process process;
    private static Stage stage;
    
    private static String readHeader() {
        try {
            return "UpdateTool GUI (v. " + new String(App.class.getResourceAsStream("/VERSION").readAllBytes(), StandardCharsets.UTF_8) + ")";
        } catch (IOException e) {
            return "UpdateTool GUI (unknown)";
        }
    }
    
    private static SimpleBooleanProperty running = new SimpleBooleanProperty();
    
    private static final ExecutorService WATCH = Executors.newSingleThreadExecutor(r -> { var t = new Thread(r); t.setDaemon(true); return t; });
    private static final ExecutorService SERVICE = Executors.newSingleThreadExecutor(r -> { var t = new Thread(r); t.setDaemon(true); return t; });
    private static final String VERSION = "https://raw.githubusercontent.com/mynttt/UpdateTool/master/VERSION";
    private static final String JAR = "https://github.com/mynttt/UpdateTool/releases/download/%s/UpdateTool-%s.jar";
    
    @Override
    public void start(Stage primaryStage) throws Exception {
        primaryStage.setScene(new Scene(FXMLLoader.load(getClass().getResource("/GUI.fxml").toURI().toURL())));
        parent = primaryStage.getScene().getRoot();
        parent.setDisable(true);
        stage = primaryStage;
        primaryStage.show();
        primaryStage.setTitle(HEADER);
        Thread.setDefaultUncaughtExceptionHandler((t, x) -> Platform.runLater(() -> Helper.exceptionDialog(x)));
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            if(process != null && process.isAlive()) {
                process.destroy();
                try {
                    process.waitFor(4, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                process.destroyForcibly();
            }
        }));
    }
    
    @FXML TextField plexFolder, tmdbKey, tvdbKey, ignoreLibs, javabinary, hours, tvshowoptin, plexsqlpath;
    @FXML CheckBox useTmdb, useTvdb, ignoreMovies, ignoreTv, plexsqlcheckbox;
    @FXML TextArea log;
    @FXML Label version, status;
    @FXML Button start, stop;
    
    @FXML
    void initialize() throws Exception {
        useTmdb.selectedProperty().bindBidirectional(INSTANCE.getUseTmdb());
        useTvdb.selectedProperty().bindBidirectional(INSTANCE.getUseTvdb());
        tmdbKey.disableProperty().bind(INSTANCE.getUseTmdb().not());
        tvdbKey.disableProperty().bind(INSTANCE.getUseTvdb().not());
        tmdbKey.textProperty().bindBidirectional(INSTANCE.getTmdbKey());
        tvdbKey.textProperty().bindBidirectional(INSTANCE.getTvdbKey());
        ignoreMovies.selectedProperty().bindBidirectional(INSTANCE.getIgnoreMovies());
        ignoreTv.selectedProperty().bindBidirectional(INSTANCE.getIgnoreTv());
        ignoreLibs.textProperty().bindBidirectional(INSTANCE.getIgnoreLibs());
        tvshowoptin.textProperty().bindBidirectional(INSTANCE.getTvShowOptIn());
        javabinary.textProperty().bindBidirectional(INSTANCE.getJavabinary());
        plexFolder.textProperty().bindBidirectional(INSTANCE.getPlexFolder());
        hours.textProperty().bindBidirectional(INSTANCE.getHours());
        plexsqlpath.textProperty().bindBidirectional(INSTANCE.getPlexNativeSqlPath());
        plexsqlcheckbox.selectedProperty().bindBidirectional(INSTANCE.getUsePlexNativeSql());
        
        BooleanBinding p = javabinary.textProperty().isEmpty()
                .or(Bindings.createBooleanBinding(() -> javabinary.getText().trim().isEmpty(), javabinary.textProperty()))
                .or(plexFolder.textProperty().isEmpty())
                .or(Bindings.createBooleanBinding(() -> {
                    Path pt = Path.of(javabinary.getText());
                    if(Files.exists(pt) && !Files.isDirectory(pt))
                        return false;
                    if(!running.get())
                        runLater(() -> log.appendText("Set proper Java 11+ binary (java / java.exe).\n"));
                    return true;
                }, javabinary.textProperty()))
                .or(Bindings.createBooleanBinding(() -> plexFolder.getText().trim().isEmpty(), plexFolder.textProperty()))
                .or(Bindings.createBooleanBinding(() -> hours.getText().trim().isEmpty(), hours.textProperty()))
                .or(Bindings.createBooleanBinding(() -> { try {Integer.parseInt(hours.getText());} catch(Exception e) { return true; } return false; }, hours.textProperty()))
                .or(Bindings.createBooleanBinding(() -> {
                    boolean error = false;
                    try {
                        error = Files.list(Path.of(plexFolder.textProperty().get()))
                                .filter(f -> f.getFileName().toString().equals("Plug-in Support"))
                                .count() == 0;
                    } catch(Exception e) {
                        error = true;
                    }
                    if(error && !running.get())
                        runLater(() -> log.appendText("Set correct plex media server folder (the one with 'Plug-in Support' in it).\n"));
                    return error;
                }, plexFolder.textProperty()));
        
        start.disableProperty().bind(p.or(running));
        stop.disableProperty().bind(running.not());
        
        running.addListener((o, oo, n) -> {
            runLater(() -> {
                stage.setTitle(n ? HEADER + " - RUNNING" : HEADER);
                status.setText(n ? "UpdateTool is running!" : "UpdateTool not running.");
            });
        });
        
        SERVICE.submit(() -> { 
            checkVersion();
            runLater(() -> parent.setDisable(false));
            runLater(() -> status.setText("Tool loaded."));
            return true; 
        });
    }
    
    private static void download(String url, Path target) throws MalformedURLException, IOException {
        Logger.info("Download: {}", url);
        URLConnection connection = new URL(url).openConnection();
        Files.copy(connection.getInputStream(), target, StandardCopyOption.REPLACE_EXISTING);
    }
    
    private void checkVersion() throws Exception {
        String version;
        runLater(() -> status.setText("Version check..."));
        if(Files.exists(APPLICATION_CONFIG.resolve("V"))) {
            version = Files.readString(APPLICATION_CONFIG.resolve("V")).trim();
            runLater(() -> log.appendText("Found version: " + version + "\n"));
            download(VERSION, APPLICATION_CONFIG.resolve("V_TEMP"));
            String v = Files.readString(APPLICATION_CONFIG.resolve("V_TEMP")).trim();
            Files.delete(APPLICATION_CONFIG.resolve("V_TEMP"));
            if(!version.equals(v) || !Files.exists(APPLICATION_CONFIG.resolve("tool.jar"))) {
                runLater(() -> log.appendText("Version not up to date. Downloading: " + v + "\n"));
                runLater(() -> status.setText("Tool download..."));
                download(String.format(JAR, v, v), APPLICATION_CONFIG.resolve("tool.jar"));
                Files.writeString(APPLICATION_CONFIG.resolve("V"), v, StandardCharsets.UTF_8);
                runLater(() -> log.appendText("Download completed.\n"));
            } else {
                runLater(() -> log.appendText("Version up to date.\n"));
            }
        } else {
            runLater(() -> log.appendText("First time downloading UpdateTool.jar\n"));
            download(VERSION, APPLICATION_CONFIG.resolve("V"));
            version = Files.readString(APPLICATION_CONFIG.resolve("V")).trim();
            runLater(() -> status.setText("Tool download..."));
            download(String.format(JAR, version, version), APPLICATION_CONFIG.resolve("tool.jar"));
            runLater(() -> log.appendText("Downloaded version: " + version + "\n"));
        }
        runLater(() -> this.version.setText(version));
    }
    
    @FXML
    void openData() throws IOException {
        Desktop.getDesktop().open(APPLICATION_CONFIG.toFile());
    }
    
    @FXML
    void start() throws IOException {
        HashMap<String, String> env = new HashMap<>();
        
        env.put("PLEX_DATA_DIR", plexFolder.getText().trim());
        if(useTmdb.isSelected())
            env.put("TMDB_API_KEY", tmdbKey.getText());
        if(useTvdb.isSelected())
            env.put("TVDB_API_KEY", tvdbKey.getText());
        if(!ignoreLibs.getText().isBlank())
            env.put("IGNORE_LIBS", ignoreLibs.getText().trim().replace(",", ";"));
        if(tvshowoptin.getText() != null) {
            if(!tvshowoptin.getText().isBlank())
                env.put("UNLOCK_FOR_NEW_TV_AGENT", tvshowoptin.getText().trim().replace(",", ";"));
        } else {
            tvshowoptin.setText("");
        }
        if(plexsqlcheckbox.isSelected() && !plexsqlpath.getText().trim().isBlank()) {
            env.put("USE_PLEX_SQLITE_BINARY_FOR_WRITE_ACCESS", plexsqlpath.getText().trim());
        }
        
        List<String> c = new ArrayList<>();
        if(ignoreTv.isSelected())
            c.add("NO_TV");
        if(ignoreMovies.isSelected())
            c.add("NO_MOVIE");
        if(!c.isEmpty())
            env.put("CAPABILITIES", String.join(";", c));
        
        ProcessBuilder pb = new ProcessBuilder(Arrays.asList(
                javabinary.getText().trim(), 
                "-jar", 
                APPLICATION_CONFIG.resolve("tool.jar").toAbsolutePath().toString(),
                "imdb-docker",
                String.format("{schedule=%s}", hours.getText().trim())))
            .directory(APPLICATION_CONFIG.toFile())
            .redirectErrorStream(true);
        pb.environment().putAll(env);
        process = pb.start();
        
        WATCH.submit(() -> {
            runLater(() -> log.clear());
            runLater(() -> log.setText("Started UpdateTool:\n\n"));
            try(BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));) {
                String buffer;
                while((buffer = br.readLine()) != null) {
                    final String payload = buffer+"\n";
                    runLater(() -> log.appendText(payload));
                }
            } catch(Exception e) {
                e.printStackTrace();
            }
            runLater(() -> log.appendText("\nUpdateTool stopped."));
            runLater(() -> running.set(false));
        });
        
        running.set(true);
    }
    
    @FXML
    void stopTool() {
        SERVICE.submit(() -> {
            process.destroy();
            try {
                process.waitFor(4, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            process.destroyForcibly();
            runLater(() -> running.set(false));
        });
    }
    
    void runLater(Runnable r) {
        Platform.runLater(r::run);
    }
}
